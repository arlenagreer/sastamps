var SAPA_GLOSSARY=(()=>{var x=Object.create;var T=Object.defineProperty;var q=Object.getOwnPropertyDescriptor;var F=Object.getOwnPropertyNames;var D=Object.getPrototypeOf,P=Object.prototype.hasOwnProperty;var E=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var I=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of F(t))!P.call(e,n)&&n!==r&&T(e,n,{get:()=>t[n],enumerable:!(s=q(t,n))||s.enumerable});return e};var u=(e,t,r)=>(r=e!=null?x(D(e)):{},I(t||!e||!e.__esModule?T(r,"default",{value:e,enumerable:!0}):r,e));var m=E((Q,M)=>{M.exports={terms:[{id:"philately",term:"Philately",slug:"philately",alternateNames:["Stamp Collecting"],definition:"The collection and study of postage stamps and related postal items.",detailedDescription:"Philately encompasses not just the collection of stamps, but also the study of their history, production methods, varieties, and postal usage. The term was coined by French collector Georges Herpin in 1864 from the Greek words 'philos' (loving) and 'ateleia' (exemption from tax), referring to the prepayment of postage.",category:"general",subcategory:"basic-concepts",examples:[{description:"Collecting stamps by country, topic, or time period",caption:"Example of a topical collection focused on space exploration"},{description:"Studying postal history through covers and cancellations"}],relatedTerms:["philatelist","postage-stamp","postal-history"],seeAlso:[{termId:"philatelist",relationship:"related"},{termId:"deltiology",relationship:"broader"}],etymology:{origin:"French, coined by Georges Herpin in 1864",meaning:"From Greek 'philos' (loving) + 'ateleia' (exemption from tax)",history:"The term replaced earlier names like 'timbrophilie' and 'timbromania'"},usage:{context:"Used to describe the hobby and study of stamps in academic and collecting contexts",formality:"formal",frequency:"common"},tags:["collecting","hobby","study","stamps","basic"],difficulty:"beginner",importance:"essential",dateAdded:"2025-06-28",dateUpdated:"2025-06-28",contributor:{name:"SAPA Education Committee",credentials:"San Antonio Philatelic Association"},status:"published"},{id:"mint",term:"Mint",slug:"mint",alternateNames:["Mint Condition","Unused"],definition:"A stamp that has never been used for postage and retains its original gum.",detailedDescription:"A mint stamp is in the same condition as when it left the post office, with original gum intact on the back. The quality of mint stamps can vary - some may be 'never hinged' (NH) meaning they've never been mounted in an album, while others may show evidence of having been hinged. Mint stamps are generally more valuable than used stamps, especially in superior condition.",category:"condition-grading",subcategory:"stamp-condition",examples:[{description:"A 1918 Inverted Jenny stamp in mint never-hinged condition",caption:"One of the most famous mint stamps in philatelic history"},{description:"Modern commemorative stamps purchased from the post office"}],relatedTerms:["never-hinged","original-gum","used","hinged"],seeAlso:[{termId:"never-hinged",relationship:"narrower"},{termId:"used",relationship:"opposite"},{termId:"original-gum",relationship:"related"}],usage:{context:"Used when describing stamp condition in catalogs, auctions, and sales",formality:"technical",frequency:"common"},tags:["condition","unused","gum","grading","value"],difficulty:"beginner",importance:"essential",dateAdded:"2025-06-28",dateUpdated:"2025-06-28",contributor:{name:"SAPA Grading Committee",credentials:"Certified philatelic experts"},status:"published"},{id:"perforation",term:"Perforation",slug:"perforation",alternateNames:["Perfs","Perforations"],definition:"Small holes punched between stamps to make separation easier.",detailedDescription:"Perforations are rows of small holes punched in stamp sheets to allow individual stamps to be easily separated. They are measured by the number of holes in a 2-centimeter span. Different perforation gauges (like 11, 12, or 14) can create varieties of the same stamp design. The quality and completeness of perforations significantly affect a stamp's value.",category:"paper-printing",subcategory:"production-methods",examples:[{description:"Standard line perforations on most modern stamps"},{description:"Compound perforations where different sides have different gauges"},{description:"Imperforate stamps that lack perforations entirely"}],relatedTerms:["perforation-gauge","imperforate","rouletting","die-cutting"],seeAlso:[{termId:"imperforate",relationship:"opposite"},{termId:"perforation-gauge",relationship:"related"},{termId:"rouletting",relationship:"related"}],usage:{context:"Essential term for describing stamp varieties and condition",formality:"technical",frequency:"common"},tags:["production","separation","holes","measurement","varieties"],difficulty:"beginner",importance:"essential",dateAdded:"2025-06-28",dateUpdated:"2025-06-28",contributor:{name:"Technical Committee",credentials:"SAPA"},status:"published"},{id:"watermark",term:"Watermark",slug:"watermark",definition:"A design or pattern pressed into paper during manufacture, visible when held to light.",detailedDescription:"Watermarks are created during paper production by varying the thickness of the paper in specific patterns. They serve as a security feature and help identify different paper types. Watermarks can be simple (letters, crowns) or complex designs. They're crucial for identifying stamp varieties, as the same stamp design printed on different watermarked papers creates collectible varieties.",category:"paper-printing",subcategory:"paper-features",examples:[{description:"Crown watermarks used in British Commonwealth stamps"},{description:"USPS watermarks with repeated 'USPS' letters"},{description:"Multiple watermarks showing different crown designs over time"}],relatedTerms:["watermark-detector","paper","security-features"],seeAlso:[{termId:"paper",relationship:"broader"},{termId:"watermark-detector",relationship:"related"}],usage:{context:"Important for stamp identification and variety classification",formality:"technical",frequency:"common"},tags:["paper","security","identification","varieties","detection"],difficulty:"intermediate",importance:"important",dateAdded:"2025-06-28",dateUpdated:"2025-06-28",contributor:{name:"Paper Studies Group",credentials:"SAPA Research Committee"},status:"published"},{id:"first-day-cover",term:"First Day Cover",slug:"first-day-cover",alternateNames:["FDC"],definition:"An envelope bearing a stamp cancelled on its first day of issue.",detailedDescription:"First Day Covers are envelopes with stamps that have been cancelled with postmarks dated the first day the stamps were officially released. They're popular collectibles that commemorate new stamp issues. Many FDCs feature special cachets (decorative designs) that relate to the stamp's subject. Official FDCs are typically cancelled at the designated first day city, often where the stamp dedication ceremony takes place.",category:"postal-history",subcategory:"covers-envelopes",examples:[{description:"Moon landing anniversary stamp on FDC with space-themed cachet"},{description:"Presidential commemorative with cachet showing the president's portrait"}],relatedTerms:["cachet","postmark","cover","first-day-ceremony"],seeAlso:[{termId:"cover",relationship:"broader"},{termId:"cachet",relationship:"related"},{termId:"postmark",relationship:"related"}],usage:{context:"Popular collecting area, often abbreviated as FDC",formality:"formal",frequency:"common"},tags:["covers","first-day","commemorative","cachets","postmarks"],difficulty:"beginner",importance:"important",dateAdded:"2025-06-28",dateUpdated:"2025-06-28",contributor:{name:"Cover Collectors Society",credentials:"SAPA Affiliate"},status:"published"}],categories:[{id:"general",name:"General Terms",description:"Basic philatelic concepts and terminology",order:1},{id:"condition-grading",name:"Condition & Grading",description:"Terms related to stamp condition and quality assessment",order:2},{id:"paper-printing",name:"Paper & Printing",description:"Technical aspects of stamp production",order:3},{id:"postal-history",name:"Postal History",description:"Terms related to postal usage and covers",order:4},{id:"perforations",name:"Perforations",description:"Perforation types and measurements",order:5}],metadata:{lastUpdated:"2025-06-28T17:29:00.000Z",totalTerms:5,version:"1.0",contributors:["SAPA Education Committee","SAPA Research Committee","Technical Committee"]}}});function f(e,t=document){try{return t.querySelector(e)}catch(r){return console.warn(`Failed to query selector "${e}":`,r),null}}async function g(){console.log("\u{1F524} Initializing glossary page...");let e=f("#glossary-search-container");e&&await G(e);let t=f("#glossary-filters-container");t&&await H(t);let r=f("#glossary-content-container");r&&await U(r),await B()}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",g):g();window.initializeGlossary=g;async function G(e){try{e.innerHTML=`
            <div class="glossary-search">
                <div class="search-header">
                    <h3><i class="fas fa-search"></i> Search Glossary</h3>
                    <p>Find philatelic terms and definitions</p>
                </div>
                <div class="search-form">
                    <div class="search-input-group">
                        <input 
                            type="search" 
                            id="glossary-search-input" 
                            placeholder="Search terms, definitions, or categories..." 
                            aria-label="Search glossary terms"
                            autocomplete="off"
                        >
                        <button id="glossary-search-button" aria-label="Search" type="button">
                            <i class="fas fa-search"></i>
                        </button>
                        <button id="glossary-clear-button" aria-label="Clear search" type="button" style="display: none;">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="search-suggestions" id="search-suggestions" style="display: none;"></div>
                </div>
                <div id="search-results" style="display: none;"></div>
            </div>
        `;let t=e.querySelector("#glossary-search-input"),r=e.querySelector("#glossary-search-button"),s=e.querySelector("#glossary-clear-button"),n=e.querySelector("#search-results"),i;t.addEventListener("input",a=>{clearTimeout(i);let o=a.target.value.trim();o.length>0?(s.style.display="block",i=setTimeout(()=>y(o,n),300)):(s.style.display="none",n.style.display="none",C())}),r.addEventListener("click",()=>{let a=t.value.trim();a&&y(a,n)}),s.addEventListener("click",()=>{t.value="",s.style.display="none",n.style.display="none",C(),t.focus()}),t.addEventListener("keypress",a=>{if(a.key==="Enter"){a.preventDefault();let o=t.value.trim();o&&y(o,n)}})}catch(t){console.error("Failed to load glossary search:",t),e.innerHTML='<p class="error-message">Unable to load search functionality.</p>'}}async function H(e){try{let{default:t}=await Promise.resolve().then(()=>u(m())),r=t.terms||[],s=[...new Set(r.map(l=>l.category))].sort(),n=[...new Set(r.map(l=>l.difficulty))].sort(),i=[...new Set(r.map(l=>l.subcategory).filter(Boolean))].sort();e.innerHTML=`
            <div class="glossary-filters">
                <div class="filters-grid">
                    <div class="filter-group">
                        <label for="category-filter">
                            <i class="fas fa-layer-group"></i> Category
                        </label>
                        <select id="category-filter" aria-label="Filter by category">
                            <option value="">All Categories</option>
                            ${s.map(l=>`<option value="${l}">${v(l)}</option>`).join("")}
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="difficulty-filter">
                            <i class="fas fa-signal"></i> Difficulty
                        </label>
                        <select id="difficulty-filter" aria-label="Filter by difficulty">
                            <option value="">All Levels</option>
                            ${n.map(l=>`<option value="${l}">${b(l)}</option>`).join("")}
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="sort-filter">
                            <i class="fas fa-sort"></i> Sort By
                        </label>
                        <select id="sort-filter" aria-label="Sort terms">
                            <option value="alphabetical">Alphabetical</option>
                            <option value="category">Category</option>
                            <option value="difficulty">Difficulty</option>
                            <option value="recent">Recently Added</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <button id="filter-reset" type="button" class="btn btn-secondary">
                            <i class="fas fa-undo"></i> Reset Filters
                        </button>
                    </div>
                </div>
                
                <div class="alphabet-nav" id="alphabet-nav">
                    <span class="alphabet-label">Jump to letter:</span>
                    ${Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZ").map(l=>`<button class="alphabet-btn" data-letter="${l}">${l}</button>`).join("")}
                </div>
            </div>
        `;let a=e.querySelector("#category-filter"),o=e.querySelector("#difficulty-filter"),c=e.querySelector("#sort-filter"),p=e.querySelector("#filter-reset"),w=e.querySelectorAll(".alphabet-btn");[a,o,c].forEach(l=>{l.addEventListener("change",$)}),p.addEventListener("click",()=>{a.value="",o.value="",c.value="alphabetical",$()}),w.forEach(l=>{l.addEventListener("click",S=>{let k=S.target.dataset.letter;j(k),w.forEach(L=>L.classList.remove("active")),S.target.classList.add("active")})})}catch(t){console.error("Failed to load glossary filters:",t),e.innerHTML='<p class="error-message">Unable to load filters.</p>'}}async function U(e){try{let{default:t}=await Promise.resolve().then(()=>u(m())),r=t.terms||[];if(r.length===0){e.innerHTML=`
                <div class="card">
                    <div class="card-content text-center">
                        <h3>No Terms Available</h3>
                        <p>The glossary is currently being updated. Please check back soon.</p>
                    </div>
                </div>
            `;return}window.glossaryTerms=r,h(r,e)}catch(t){console.error("Failed to load glossary content:",t),e.innerHTML=`
            <div class="card">
                <div class="card-content text-center">
                    <h3>Error Loading Glossary</h3>
                    <p>Unable to load glossary terms. Please try refreshing the page.</p>
                </div>
            </div>
        `}}function h(e,t){if(e.length===0){t.innerHTML=`
            <div class="card">
                <div class="card-content text-center">
                    <h3>No Terms Found</h3>
                    <p>No terms match your current search or filter criteria.</p>
                </div>
            </div>
        `;return}let r={};e.forEach(i=>{let a=i.term.charAt(0).toUpperCase();r[a]||(r[a]=[]),r[a].push(i)});let n=Object.keys(r).sort().map(i=>`
        <div class="glossary-section" id="section-${i}">
            <h2 class="glossary-letter-header">${i}</h2>
            <div class="glossary-terms">
                ${r[i].map(a=>N(a)).join("")}
            </div>
        </div>
    `).join("");t.innerHTML=n,t.addEventListener("click",i=>{if(i.target.closest(".term-header")){let a=i.target.closest(".glossary-term"),o=a.querySelector(".term-content"),c=a.querySelector(".expand-icon");o.style.display==="none"||!o.style.display?(o.style.display="block",c.style.transform="rotate(180deg)",a.classList.add("expanded")):(o.style.display="none",c.style.transform="rotate(0deg)",a.classList.remove("expanded"))}if(i.target.closest(".related-term")){i.preventDefault();let a=i.target.closest(".related-term").dataset.termId;A(a)}})}function N(e){let t=b(e.difficulty),r=v(e.category);return`
        <div class="glossary-term" id="term-${e.id}" data-term-id="${e.id}">
            <div class="term-header">
                <div class="term-title-group">
                    <h3 class="term-title">${d(e.term)}</h3>
                    ${e.alternateNames&&e.alternateNames.length>0?`<div class="alternate-names">
                            Also known as: ${e.alternateNames.map(s=>d(s)).join(", ")}
                        </div>`:""}
                </div>
                <div class="term-meta">
                    <span class="difficulty-badge difficulty-${e.difficulty}">${t}</span>
                    <span class="category-badge">${r}</span>
                    <i class="fas fa-chevron-down expand-icon"></i>
                </div>
            </div>
            
            <div class="term-content" style="display: none;">
                <div class="term-definition">
                    <p class="definition">${d(e.definition)}</p>
                    ${e.detailedDescription?`<div class="detailed-description">
                            <p>${d(e.detailedDescription)}</p>
                        </div>`:""}
                </div>
                
                ${e.examples&&e.examples.length>0?`
                    <div class="term-examples">
                        <h4><i class="fas fa-lightbulb"></i> Examples</h4>
                        <ul>
                            ${e.examples.map(s=>`
                                <li>
                                    ${d(s.description)}
                                    ${s.caption?`<span class="example-caption">${d(s.caption)}</span>`:""}
                                </li>
                            `).join("")}
                        </ul>
                    </div>
                `:""}
                
                ${e.etymology?`
                    <div class="term-etymology">
                        <h4><i class="fas fa-history"></i> Etymology</h4>
                        <p><strong>Origin:</strong> ${d(e.etymology.origin)}</p>
                        <p><strong>Meaning:</strong> ${d(e.etymology.meaning)}</p>
                        ${e.etymology.history?`<p><strong>History:</strong> ${d(e.etymology.history)}</p>`:""}
                    </div>
                `:""}
                
                ${e.relatedTerms&&e.relatedTerms.length>0?`
                    <div class="related-terms">
                        <h4><i class="fas fa-link"></i> Related Terms</h4>
                        <div class="related-terms-list">
                            ${e.relatedTerms.map(s=>`<a href="#term-${s}" class="related-term" data-term-id="${s}">${O(s)}</a>`).join("")}
                        </div>
                    </div>
                `:""}
                
                ${e.tags&&e.tags.length>0?`
                    <div class="term-tags">
                        ${e.tags.map(s=>`<span class="tag">${d(s)}</span>`).join("")}
                    </div>
                `:""}
            </div>
        </div>
    `}async function y(e,t){try{let{default:r}=await Promise.resolve().then(()=>u(m())),s=r.terms||[],n=e.toLowerCase(),i=s.filter(a=>a.term.toLowerCase().includes(n)||a.definition.toLowerCase().includes(n)||a.detailedDescription&&a.detailedDescription.toLowerCase().includes(n)||a.tags&&a.tags.some(o=>o.toLowerCase().includes(n))||a.category&&a.category.toLowerCase().includes(n)||a.alternateNames&&a.alternateNames.some(o=>o.toLowerCase().includes(n)));i.length===0?t.innerHTML=`
                <div class="search-no-results">
                    <p><strong>No results found for "${d(e)}"</strong></p>
                    <p>Try searching for related terms or browse by category.</p>
                </div>
            `:t.innerHTML=`
                <div class="search-results-header">
                    <p>Found <strong>${i.length}</strong> result${i.length!==1?"s":""} for "<strong>${d(e)}</strong>"</p>
                </div>
                <div class="search-results-list">
                    ${i.map(a=>`
                        <div class="search-result-item">
                            <h4><a href="#term-${a.id}" onclick="scrollToTerm('${a.id}')">${d(a.term)}</a></h4>
                            <p class="result-definition">${d(a.definition)}</p>
                            <div class="result-meta">
                                <span class="result-category">${v(a.category)}</span>
                                <span class="result-difficulty">${b(a.difficulty)}</span>
                            </div>
                        </div>
                    `).join("")}
                </div>
            `,t.style.display="block"}catch(r){console.error("Search failed:",r),t.innerHTML='<p class="error-message">Search temporarily unavailable. Please try again.</p>',t.style.display="block"}}function $(){let e=document.querySelector("#category-filter")?.value||"",t=document.querySelector("#difficulty-filter")?.value||"",r=document.querySelector("#sort-filter")?.value||"alphabetical";if(!window.glossaryTerms)return;let s=[...window.glossaryTerms];switch(e&&(s=s.filter(i=>i.category===e)),t&&(s=s.filter(i=>i.difficulty===t)),r){case"category":s.sort((a,o)=>a.category!==o.category?a.category.localeCompare(o.category):a.term.localeCompare(o.term));break;case"difficulty":let i={beginner:1,intermediate:2,advanced:3};s.sort((a,o)=>{let c=i[a.difficulty]||999,p=i[o.difficulty]||999;return c!==p?c-p:a.term.localeCompare(o.term)});break;case"recent":s.sort((a,o)=>{let c=new Date(a.dateAdded||"1970-01-01");return new Date(o.dateAdded||"1970-01-01")-c});break;case"alphabetical":default:s.sort((a,o)=>a.term.localeCompare(o.term));break}let n=document.querySelector("#glossary-content-container");n&&h(s,n)}function C(){let e=document.querySelector("#glossary-content-container");e&&window.glossaryTerms&&h(window.glossaryTerms,e)}function j(e){let t=document.querySelector(`#section-${e}`);t&&t.scrollIntoView({behavior:"smooth",block:"start"})}function A(e){let t=document.querySelector(`#term-${e}`);if(t){t.scrollIntoView({behavior:"smooth",block:"center"});let r=t.querySelector(".term-content"),s=t.querySelector(".expand-icon");r&&r.style.display!=="block"&&(r.style.display="block",s&&(s.style.transform="rotate(180deg)"),t.classList.add("expanded")),t.classList.add("highlighted"),setTimeout(()=>t.classList.remove("highlighted"),2e3)}}async function B(){try{let{default:e}=await Promise.resolve().then(()=>u(m())),t=e.terms||[],r=t.length,s=new Set(t.map(c=>c.category)).size,n=t.reduce((c,p)=>c+(p.relatedTerms?.length||0),0),i=document.querySelector("#total-terms"),a=document.querySelector("#total-categories"),o=document.querySelector("#total-references");i&&(i.textContent=r),a&&(a.textContent=s),o&&(o.textContent=n)}catch(e){console.error("Failed to load glossary stats:",e)}}function v(e){return e.split("-").map(t=>t.charAt(0).toUpperCase()+t.slice(1)).join(" ")}function b(e){return e.charAt(0).toUpperCase()+e.slice(1)}function O(e){return e.split("-").map(t=>t.charAt(0).toUpperCase()+t.slice(1)).join(" ")}function d(e){if(!e)return"";let t=document.createElement("div");return t.textContent=e,t.innerHTML}window.scrollToTerm=A;})();
